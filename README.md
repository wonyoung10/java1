# 정원영(202530127)

- [0925 강의](#9월-25일-강의)
- [0918 강의](#9월-18일-강의)
- [0911 강의](#9월-11일-강의)
- [0904 강의](#9월4일-강의)

<br>


# (10월 2일 강의)


## break
- 반복문 하나를 즉시 벗어날 때 사용. 하나의 반복문만 벗어남.
- 중첩 반복의 경우 안쪽 반복문의 break문이 실행되면 안쪽 반복문만 벗어남

## 배열 (array)
자체적으로 자료구조 할수 있다.
- 인덱스와 인덱스에 `대응하는 데이터`들로 이루어진 자료구조로 `한 번에 많은 메모리 공간 선언`
- `같은 타입의 데이터`들이 `순차적으로 저장`되는 공간으로 `인덱스를 이용하여 원소데이터 접근`
- `반복문을 이용하여 처리`하기에 적합한 자료 구조
- 배열 인덱스 : 0 부터 시작


```
int intArray [];
[배열 타입] [배열에 대한 레퍼런스 변수] [배열선언]
```

```
intArray = new int [5];
[배열에 대한 레퍼런스] [배열생성] [타입] [원소 개수]
```

### 배열 선언 및 생성 디테일
- 배열은 선언과 생성의 두단계 필요 : 선언과 동시에 생성할 수 있다
  - int intArray [] or int[] intArray;
  - int intArray[5] <- 오류 크기를 지정함
- 배열 선언 : 배열의 이름 선언(배열 레퍼런스 변수 선언)
- 배열 생성 : 배열 공간 할당 받는 과정
- 배열 초기화 : 배열 생성과 값 초기화

### 배열 인덱스와 배열 원소 접근
- 배열 인덱스는 0부터, 크기는 1부터 이다.
- -인덱스는 없다.
- 배열 생성 후 접근 : 레퍼런스만 선언 하면 안돼고 배열 생성 후 접근 해야한다.
```
int arr[];
arr[1] = 8; <- 오류 발생

int arr = new int[5];
```

### 레퍼런스 치환과 배열 공유
- 레퍼런스 치환으로 레퍼런스가 하나의 배열 공유
```
int arr = new int[5];
int myArr = arr; <- 레퍼런스 치환으로 배열 공유
```
포인터로 둘이 같은 메모리 주소를 보고 있다.   


## 배열의 크기 length 필드
- 자바의 배열은 객체로 처리
- 배열의 크기는 배열 객체의 length 필드에 저장

## 배열과 for - each 문
- for-each 문 배열이나 나열(enumeration)의 원소를 순차 접근하는데 유용한 for 문

## 2차원 배열
- 2차원 배열 선언
  - `int arr[][]; or int[][]`
- 2차원 배열 생성
  - `int arr = new int[2][5];`
- 2차원 배열 선언 + 생성
  - `int arr = new int[2][5]`

### 2차원 배열의 length 필드
- i.length : 2차원 배열의 행의 개수이므로 2개
- i[n].length : n번째 행의 열의 개수

## 메소드(함수)의 배열 리턴
- 배열의 레퍼런스만 리턴되며, 배열 전체가 리턴되는 것이 아니다.
- 메소드의 리턴 타입
  - 리턴 타입에 배열의 크기를 지정하지 않음
  - 리턴하는 배열 타입과 리턴 받는 배열 타입 일치

## 자바의 예외 처리
- 어떤 수를 0으로 나누기 시 에외 발생

### try-catch-finally 문
- 예외 처리 : 발생한 예외에 대해 개발자가 작성한 프로그램 코드에서 대응하는 것
- try-catch-finally문 사용
```
try {
  실행문
}
catch(처리할 예외 타입 선언) {

}
finally {
finally 블록문
}

```
### 예외 - 클래스 사례
- 배열의 범위를 벗어나 원소를 접근하는 예외 처리
<br>

# (9월 25일 강의)

## 반복문
  
### for 
- 조건 횟수가 정해져 있을때  
- 조건식이 `참`인 동안 반복 실행
```
for(초기문; 조건식;반복후 작업) {
  작업문
}
```
### while
- 조건 횟수가 정해져 있지 않을 때
- 조건식이 `참`인 동안 반복 실행
```
while(조건) {
  작업문
}
```

### while
- 조건 횟수가 정해져 있지 않을 때
- 조건식이 `참`인 동안 반복 실행
- 작업문은 한 번 반드시 실행
```
do{
  작업문
}while(조건)
```

### 중첩 반복
  - 반복문이 다른 반복문을 내포하는 구조
  ```
  예시
  for(int i =0;i<10;i++) {
    for(int j=0;j<10;j++)
  }
  ```

## switch 문
 - case의 비교값과 일치하면 해당 case의 실행문장 수행
 - break를 만나면 switch문을 벗어남
 - case의 비교 값과 일치하는 것이 없으면 default 문 실행
 - default문은 생략 가능
 ```
 기본 구조

 switch(조건) {
  case 값1 :
    break;
  case 값2 :
    break;
  default :
    break;
 }
 ```
### case 문의 값
  - 문자, 정수, 문자열 리터럴( JDK 1.7부터 )만 허용
  - 실수 리터럴은 허용되지 않음
  ```
  예시
  case '+' :
  case 1   : 
  case '예':
  case '2' :
  ```


## 조건문

### 단순 if문
  - if의 괄호 안에 조건식
  - 실행문장이 단일 문장인 경우 둘러싸는 {, } 생각 가능

### if - else 문
```
if(조건) {
  실행문장 1
}
else{
  실행문장2
}
```
- 조건식이 true면 실행문장1, false이면 실행문장2 실행

### 다중 if - else 문
  - 다중 if 문
  - 조건문이 너무 많은 경우, switch 문 사용 권장  
  ```
  if(조건1){
  } 
  else if(조건2) {

  } 
  else
  ```

## 대입연산자 , 비교 연산 ,논리 연산
[0918 강의 참조](#연산자)
- 대입  
  - `=` : 대입  
  - `*=` : 곱 후 대입  
  - `/=` : 나눈 후 대입  
  - `+=` : 더한 후 대입  
  - `-=` : 뺀 후 대입  
  - `&=` : 비트 AND 후 대입  
  - `^=` : 비트 XOR 후 대입  
  - `|=` : 비트 OR 후 대입  
  - `<<=` : 왼쪽 시프트 후 대입  
  - `>>=` : 오른쪽 시프트 후 대입  
  - `>>>=` : 부호 무시 오른쪽 시프트 후 대입  
  
- 비교  
  - `>` : 크다  
  - `<` : 작다  
  - `>=` : 크거나 같다  
  - `<=` : 작거나 같다  
  - `==` : 같다 (값 비교)  
  - `!=` : 같지 않다  


- 논리  
  - `&&` : 논리 AND (그리고)  
  - `||` : 논리 OR (또는)  
  - `!` : 논리 NOT (부정)  
  - `^` : 논리 XOR (배타적 OR) 

## D2coding
  손으로 코딩하던 시절 여러 규칙들이 있었다.


## 삼항연산자
  3 개의 피 연산자로 구성된 연산자
  <br>
  opr1?opr2:opr3 -> opr1이 결과가, true면 opr2, false면 opr3
  <br>
  if~else을 조건연산자로 간결하게 표현 가능

## 비트연산
  어떨때 쓸거 같다는 느낌
  1. 데이터 압축 및 최적화
  2. 해싱 및 암호화
  3. 빠른 연산


# (9월 18일 강의)
## 자바의 특징
- 가비지 콜렉터(Garbage Collector, GC)
- 실기간 응용프로그램에 부적합
- 자바는 안전
- 프로그램 작성 쉬움
- 실행 속도 개선을위한 JIT 컴파일러 사용
    1. 바이드 코드를 인터프리터 방식 실행
    2. 기계어 보다 느림

## 코드 
1. 소스코드
    - `.java` 코드
    - 사람이 읽을 수 있는 고수준 언어 (High-Level Languag)
2. 바이코드
    - `.class` 코드
    - Java 컴파일러(javac)가 소스코드를 변환한 중간 코드
    - `JVM`이 실행 해야함 -> cpu가 실행 X
    - JIT 컴파일러가 기계어로 변환 실행
3. 기계어
    - cpu가 직접 실행 가능 - 0과 1의 이진 코드
    - 운영체제(os)와 cpu 아키텍처(intel , arm 등)에 따라 다름
    - 16진수 형태의 기계어

## 기본 구조
주석 / 클래스 생성/  main() 메서드/ 메서드 / 메소드 호출 / 변수 선언 / 문장 ; / 출력

### 식별자

- **정의** - 클래스 , 변수, 상수, 메소드에 붙이는 이름

- 유니코드 사용 가능, 한글 사용 가능 -> 한글 사용은 좋지 않다. 

- 자바의 언어 키워드는 식별자로 사용 불가

- 식별자의 첫 번째 문자로 숫자는 사용불가

- `_` , `$`를 식별자 첫번째 문자로 사용 할수는있다. 허나 일반적으로는 사용 안함

- 불릿 리터럴 `(true , false)`과 널 리터럴`(null)`은 식별자로 **사용불가**

- 길이 제한 없음

- 대소문자 구별 : `barChart` 와  `bahrchart`는 다른 식별자

## 데이터 타입
- 문자열은 기본 타입x, string 클래스로 문자열 표현

- 리터럴 : -> int a = `10` 에서 10 을 의미

- 문자열이나 문자열과 다른 자료형의 리터럴을 + 연산을 할 경우 결과는 문자열로 반환
- 객체를 참조하는 변수 유형, 힙(Heap) 영역에 저장된 객체의 메모리 주소를 가르킴
    - 기본 자료형은 스택 영역에 저장
- 객체를 참조 하지 않을 때 null 값을 가질수 있다.

- 일반적으로 `레퍼런스`라고 부른다.
## 참조 자료형 (Reference Type)
- 포인터는 임의의 메로리 주소를 저장 , 참조 자료형은 주소를 저장 X
- JVM이 해당 주소로 안내
- 객체를 참조하는 변수 휴형


## 메모리 관리
- jvm 이 관리 해준다.

## 메모리 구조

- 힙( heap - FIFO) 영역은 프로그래머가 직접 공간을 할당, 해제하는 메모리 공간, jvm이 담당
- 스택(stack - LIFO) 영역은 프로그램이 자동으로 사용하는 임시 메모리 영역
- 힙이 스택을 침범하는 경우를 힙 오버 플로우라고 한다. 
    - 스택이 힙을 침범하는 경우를 스택 오버 플로우

## 상수 선언
- final 키워드 사용
- 선언할 때 초기값 지정
- 실행 중 값 변경 불가능

## var 키워드
- type을 생략하고 변수 선언 
- 지역 변수에만 선언 가능 , class 필드에서는 사용할 수 없다.
    - 지역 변수 : 메소드 내부에 선언되는 변수.
    - 클래스 필드 : 클래스 내부에 선언되는 변수, 객체 생성과 함께 만들어지는 변수 
- 기본적으로는 명시적 자료형을 쓰는 것이 좋다


## print
- `System.out.print();`
- `System.out.println();`
- `System.out.printf();`


## 타입 변환
- 원래 타입보다 큰 타입으로 자동 변환
- 강제 변환
## java의 키 입력 
- System.in vs. Scanner
### Sysytem.in
- 키보드와 연결된 자바의 표준 입력 스트림
- 입력되는 키를 `바이트(문자 아님)로 리턴하는 저수준 스트림`
- 직접 사용하면 `바이트를 문자나 숫자로 변환하는 많은 어려움 있음`
### java.utill.Scanner
- 객체를 생성해서 사용
- 키보드에 연결된 System.in에게 키를 읽게 하고, 원하는 타입으로 변환하여 리턴
- 입력되는 키 값을 공백으로 구분되는 토큰 단위로 읽음
- 공백 문자 : `'/t' '/r' '/n' '' '/f'`(페이지 나누기, 폼 피드, 프린트 에서 사용)

## Scanner 주요 메서드
이런게 있다~

## 연산자
- 증감  
  - `++` : 변수 값을 1 증가  
  - `--` : 변수 값을 1 감소  

- 산술  
  - `+` : 더하기  
  - `-` : 빼기  
  - `*` : 곱하기  
  - `/` : 나누기  
  - `%` : 나머지  

- 시프트  
  - `>>` : 오른쪽 시프트 (부호 유지)  
  - `<<` : 왼쪽 시프트  
  - `>>>` : 오른쪽 시프트 (부호 무시, 0으로 채움)  

- 비교  
  - `>` : 크다  
  - `<` : 작다  
  - `>=` : 크거나 같다  
  - `<=` : 작거나 같다  
  - `==` : 같다 (값 비교)  
  - `!=` : 같지 않다  

- 비트  
  - `&` : 비트 AND  
  - `|` : 비트 OR  
  - `^` : 비트 XOR  
  - `~` : 비트 NOT  

- 논리  
  - `&&` : 논리 AND (그리고)  
  - `||` : 논리 OR (또는)  
  - `!` : 논리 NOT (부정)  
  - `^` : 논리 XOR (배타적 OR)  

- 조건  
  - `? :` : 조건 연산자 (삼항 연산자)  

- 대입  
  - `=` : 대입  
  - `*=` : 곱 후 대입  
  - `/=` : 나눈 후 대입  
  - `+=` : 더한 후 대입  
  - `-=` : 뺀 후 대입  
  - `&=` : 비트 AND 후 대입  
  - `^=` : 비트 XOR 후 대입  
  - `|=` : 비트 OR 후 대입  
  - `<<=` : 왼쪽 시프트 후 대입  
  - `>>=` : 오른쪽 시프트 후 대입  
  - `>>>=` : 부호 무시 오른쪽 시프트 후 대입  
  
<br>

# (9월 11일 강의)

Pascal Case 
camelCase
cabab-case
Snaek_case

서블릿(servlet) - Backend

<br>

# (9월4일 강의)
# Markdwon 문법

## HTML에서 `<h1>` ~ `<h6>`

# 글자 크기  
## 글자 크기
### 글자 크기
#### 글자 크기
##### 글자 크기
###### 글자 크기

# 문자 강조
*이탤릭체*  
**굵은 문자**

수평선
***

# 리스트 
* 언오더드 리스트
* 언오더드 리스트
* 언오더드 리스트
    * 언오더드 리스트
    * 언오더드 리스트
    * 언오더드 리스트
        * 언오더드 리스트
        * 언오더드 리스트
        * 언오더드 리스트

1. 오더드리스트
1. 오더드리스트
1. 오더드리스트


``` java
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello World");
    }
}
```
인라인 코드는 `버튼`이나 코드 조각을 강조할 때 사용

Vs Code에서 터미널을 열려면 `Ctrl` + `~`


# 링크

## 외부 링크
[구글 접속](https://google.com "구글 주소")

## 내부 링크
[링크 라벨](#markdwon-문법 "markdwon-문법")

# 그림 삽입
![git 로고](./git.png);